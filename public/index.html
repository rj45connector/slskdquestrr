<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> ğ“…ª slskdquestrr </title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg0h:     #1d2021;
            --bg0:      #282828;
            --bg1:      #3c3836;
            --bg2:      #504945;
            --bg3:      #665c54;
            --bg4:      #7c6f64;
            --fg:       #ebdbb2;
            --fg2:      #d5c4a1;
            --fg3:      #a89984;
            --gray:     #928374;
            --red:      #fb4934;
            --green:    #b8bb26;
            --yellow:   #fabd2f;
            --blue:     #83a598;
            --purple:   #d3869b;
            --aqua:     #8ec07c;
            --orange:   #fe8019;
            --blue-d:   #458588;
            --orange-d: #d65d0e;
            --aqua-d:   #689d6a;
            --radius:       10px;
            --card-max:     660px;
            --table-max:    840px;
            --card-pad:     24px;
            --card-gap:     18px;
            --font:         'JetBrains Mono', monospace;
            --speed:        0.25s;
            --ease:         cubic-bezier(.4,0,.2,1);
            --shadow-hover: 0 8px 28px rgba(0,0,0,0.4);
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: var(--font);
            background: var(--bg0h);
            color: var(--fg);
            padding: 28px 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
        }
        @keyframes enter {
            from { opacity: 0; transform: translateY(22px) scale(.97); }
            to   { opacity: 1; transform: translateY(0)   scale(1); }
        }
        @keyframes fadeUp {
            from { opacity: 0; transform: translateY(5px); }
            to   { opacity: 1; transform: translateY(0); }
        }
        @keyframes pulse {
            0%,100% { opacity: 1; }
            50%     { opacity: .32; }
        }
        @keyframes shimmer {
            0%   { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        .title {
            color: var(--yellow);
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 24px;
            letter-spacing: -.5px;
            animation: enter .55s var(--ease) both;
        }
        .card {
            background: var(--bg1);
            padding: var(--card-pad);
            border-radius: var(--radius);
            width: 100%;
            max-width: var(--card-max);
            border: 1px solid var(--bg2);
            margin-bottom: var(--card-gap);
            animation: enter .55s var(--ease) both;
            transition:
                border-color var(--speed) var(--ease),
                box-shadow   var(--speed) var(--ease),
                transform    var(--speed) var(--ease);
            will-change: transform;
        }
        .card:nth-of-type(1) { animation-delay: .06s; }
        .card:nth-of-type(2) { animation-delay: .14s; }
        .card:hover {
            border-color: var(--bg3);
            box-shadow: var(--shadow-hover);
            transform: translateY(-2px);
        }
        .card-label {
            color: var(--aqua);
            font-size: .9rem;
            font-weight: 600;
            margin-bottom: 16px;
        }
        .toggle {
            display: flex;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--bg2);
            margin-bottom: 10px;
        }
        .tog {
            flex: 1;
            padding: 10px 0;
            border: none;
            background: var(--bg2);
            color: var(--fg3);
            font: 500 .78rem var(--font);
            cursor: pointer;
            transition: all var(--speed) var(--ease);
            position: relative;
        }
        .tog::after {
            content: '';
            position: absolute; bottom: 0; left: 50%; width: 0; height: 2px;
            background: var(--orange);
            transition: all var(--speed) var(--ease);
            transform: translateX(-50%);
        }
        .tog:first-child { border-right: 1px solid var(--bg1); }
        .tog.on { background: var(--orange-d); color: var(--bg0); font-weight: 700; }
        .tog.on::after { width: 60%; }
        .tog:hover:not(.on) { background: var(--bg3); color: var(--fg); }
        .hint {
            font-size: .62rem;
            color: var(--gray);
            line-height: 1.7;
            margin-bottom: 12px;
            transition: opacity .3s var(--ease);
        }
        .hint strong { color: var(--fg3); }
        .inp {
            width: 100%;
            padding: 12px 14px;
            border-radius: 8px;
            border: 2px solid var(--bg2);
            background: var(--bg0);
            color: var(--fg);
            font: .85rem var(--font);
            margin-bottom: 12px;
            outline: none;
            transition:
                border-color var(--speed) var(--ease),
                box-shadow   var(--speed) var(--ease);
        }
        .inp::placeholder { color: var(--bg3); }
        .inp:focus {
            border-color: var(--blue);
            box-shadow: 0 0 0 3px rgba(69,133,136,.18);
        }
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: var(--blue-d);
            color: var(--fg);
            font: 700 .85rem var(--font);
            cursor: pointer;
            letter-spacing: .4px;
            transition: all .2s var(--ease);
            position: relative;
            overflow: hidden;
        }
        .btn::before {
            content: '';
            position: absolute; inset: 0;
            background: linear-gradient(90deg,transparent,rgba(255,255,255,.06),transparent);
            background-size: 200% 100%;
            opacity: 0;
            transition: opacity .3s;
        }
        .btn:hover:not(:disabled) {
            background: var(--blue);
            color: var(--bg0);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(69,133,136,.35);
        }
        .btn:hover:not(:disabled)::before {
            opacity: 1;
            animation: shimmer 1.5s infinite;
        }
        .btn:active:not(:disabled) { transform: translateY(0); box-shadow: none; }
        .btn:disabled {
            background: var(--bg2); color: var(--bg3);
            cursor: not-allowed; transform: none;
        }
        #status { margin-top: 14px; min-height: 18px; font-size: .72rem; line-height: 1.7; word-break: break-word; }
        .st      { display: inline-block; animation: fadeUp .28s var(--ease); }
        .s-ok    { color: var(--green); }
        .s-err   { color: var(--red); }
        .s-load  { color: var(--orange); animation: pulse 1.6s ease-in-out infinite !important; }
        .s-mute  { color: var(--gray); }
        .scroll { overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; font-size: .7rem; }
        th {
            background: var(--bg2); color: var(--fg2);
            padding: 9px 10px; text-align: left;
            font-weight: 600; white-space: nowrap;
        }
        td {
            padding: 7px 10px;
            border-bottom: 1px solid var(--bg2);
            max-width: 220px; overflow: hidden;
            text-overflow: ellipsis; white-space: nowrap;
            color: var(--fg2);
        }
        tbody tr { transition: background var(--speed) var(--ease); }
        tbody tr:hover { background: rgba(80,73,69,.25); }
        .bar-bg {
            background: var(--bg2);
            width: 100%; height: 5px;
            border-radius: 3px;
            overflow: hidden; margin-bottom: 3px;
        }
        .bar-fg {
            height: 100%; width: 0%;
            border-radius: 3px;
            background: linear-gradient(90deg, var(--aqua-d), var(--aqua));
            transition: width .7s var(--ease);
        }
        .empty { text-align: center; color: var(--bg3); font-style: italic; padding: 18px 10px !important; }

        /* â”€â”€ retry notifications â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .retry-bar {
            background: var(--bg2);
            border-radius: 8px;
            padding: 9px 14px;
            margin-top: 10px;
            font-size: .68rem;
            color: var(--fg3);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            animation: fadeUp .28s var(--ease);
        }
        .retry-bar .query { color: var(--fg2); font-weight: 600; }
        .retry-bar .src   { color: var(--gray); }
        .retry-btn {
            font: 600 .62rem var(--font);
            background: var(--orange-d);
            color: var(--fg);
            border: none;
            border-radius: 5px;
            padding: 5px 12px;
            cursor: pointer;
            transition: all .2s var(--ease);
            white-space: nowrap;
            flex-shrink: 0;
        }
        .retry-btn:hover {
            background: var(--orange);
            color: var(--bg0);
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(214,93,14,.3);
        }

        /* â”€â”€ cat filter button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .dl-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        .dl-head .card-label { margin-bottom: 0; }
        .cat-btn {
            background: none;
            border: 1px solid transparent;
            color: var(--gray);
            font-size: 1.15rem;
            padding: 4px 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all .3s var(--ease);
            line-height: 1;
        }
        .cat-btn:hover {
            color: var(--yellow);
            transform: scale(1.25) rotate(-10deg);
        }
        .cat-btn.on {
            color: var(--orange);
            background: rgba(214,93,14,.15);
            border-color: var(--orange-d);
        }
        .cat-btn.on:hover {
            color: var(--yellow);
        }

        /* â”€â”€ pagination â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .pager {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            padding-top: 12px;
        }
        .pg-btn {
            background: var(--bg2);
            border: none;
            color: var(--fg3);
            font: 600 .72rem var(--font);
            padding: 4px 11px;
            border-radius: 5px;
            cursor: pointer;
            transition: all .15s var(--ease);
        }
        .pg-btn:hover:not(:disabled) {
            background: var(--bg3);
            color: var(--fg);
        }
        .pg-btn:disabled { opacity: .2; cursor: default; }
        .pg-info {
            font-size: .62rem;
            color: var(--fg3);
            min-width: 50px;
            text-align: center;
        }
        .pg-note {
            font-size: .58rem;
            color: var(--bg4);
            margin-left: 6px;
        }

        @media (max-width:520px) {
            body { padding: 14px 6px; }
            .card { padding: 16px; }
            td,th { padding: 5px 6px; font-size: .64rem; }
            td { max-width: 110px; }
            .retry-bar { flex-direction: column; align-items: flex-start; gap: 6px; }
        }
    </style>
</head>
<body>

<h1 class="title"> ğ“…ª slskdquestrr </h1>

<div class="card">
    <div class="card-label">search & download</div>

    <div class="toggle">
        <button class="tog on" onclick="setMode('album',this)">âŠ album</button>
        <button class="tog"    onclick="setMode('track',this)">â™« track</button>
    </div>

    <div class="hint" id="hint">
        downloads a complete album folder in the best available quality (prefers FLAC).<br>
        try: <strong>pink floyd dark side of the moon</strong> Â· <strong>daft punk discovery</strong>
    </div>

    <input class="inp" type="text" id="q"
           placeholder="artist album..."
           autocomplete="off"
           onkeydown="if(event.key==='Enter')go()">

    <button class="btn" id="goBtn" onclick="go()">search & download</button>
    <div id="status"><span class="st s-mute">ready.</span></div>
</div>

<div class="card" style="max-width:var(--table-max)">
    <div class="dl-head">
        <div class="card-label">downloads</div>
        <button class="cat-btn" onclick="toggleFilter()" title="hide completed â€” show active only">ğ“ƒ </button>
    </div>
    <div class="scroll">
        <table>
            <thead><tr><th>file</th><th>user</th><th>progress</th><th>state</th></tr></thead>
            <tbody id="dl"><tr><td colspan="4" class="empty">nothing yet.</td></tr></tbody>
        </table>
    </div>
    <div id="pager" class="pager"></div>
    <div id="retries"></div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script src="/config.js"></script>
<script>
/* â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
   â•‘  CONFIG                                                          â•‘
   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const CFG = {

    // â”€â”€â”€ Connection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    API_KEY     : (window.SLSKD_CONFIG && window.SLSKD_CONFIG.API_KEY)  || '',
    API_BASE    : (window.SLSKD_CONFIG && window.SLSKD_CONFIG.API_BASE) || '/api/v0',

    // â”€â”€â”€ Search Timing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    POLLS       : 24,
    DELAY       : 2500,

    // â”€â”€â”€ Album Rules â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    MIN_TRACKS  : 4,
    REL_GATE    : 0.45,

    // â”€â”€â”€ Quality â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    MIN_KBPS    : 128,

    // â”€â”€â”€ Scoring Weights â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    W_REL       : 200,
    W_FLAC      : 100,
    W_320       : 65,
    W_256       : 45,
    W_192       : 30,
    W_LOW       : 8,
    W_TRACK     : 3,
    W_TRACK_CAP : 45,
    W_SLOT      : 25,
    W_Q_PEN     : 0.4,
    W_Q_CAP     : 25,
    W_NOISE     : 90,

    // â”€â”€â”€ Early-Exit Thresholds â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ALBUM_EXIT_REL   : 0.75,
    ALBUM_EXIT_SCORE : 280,
    ALBUM_EXIT_FILES : 6,
    ALBUM_EXIT_POLL  : 6,
    TRACK_EXIT_REL   : 0.7,
    TRACK_EXIT_SCORE : 240,
    TRACK_EXIT_POLL  : 4,

    // â”€â”€â”€ Instant Retry â€” reject / immediate failures â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    RETRY       : 5,
    RETRY_MS    : 12000,
    RETRY_POLL  : 1500,

    // â”€â”€â”€ Background Watcher â€” timeout / delayed failures â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    WATCH_GRACE : 90000,
    WATCH_MAX   : 3,
    WATCH_POLL  : 10000,

    // â”€â”€â”€ Download Monitor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    MON_MS      : 2500,
    PER_PAGE    : 15
};
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */


/* â”€â”€ constants & state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const AUDIO = /\.(flac|mp3|ogg|opus|m4a|aac|wav|wma|alac|ape|wv)$/i;
const NOISE = /\b(cover|covers|covered|remix|remixed|remixes|bootleg|tribute|karaoke|mashup|8[- ]?bit)\b/i;
const STOPS = new Set(
    'a an the and or for but not of to in on at by is it its this that with from as so if'.split(' ')
);

let mode        = 'album';
let showActive  = false;   // cat filter state
let dlPage      = 1;       // current table page
const watchlist = new Map();
let lastWatch   = 0;


/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• UI HELPERS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

function setMode(m, el) {
    mode = m;
    document.querySelectorAll('.tog').forEach(b => b.classList.remove('on'));
    el.classList.add('on');
    const h = document.getElementById('hint');
    const q = document.getElementById('q');
    if (m === 'album') {
        h.innerHTML =
            'downloads a complete album folder in the best available quality (prefers FLAC).<br>' +
            'try: <strong>pink floyd dark side of the moon</strong> Â· <strong>daft punk discovery</strong>';
        q.placeholder = 'artist album...';
    } else {
        h.innerHTML =
            'finds the single best-quality file matching your search.<br>' +
            'try: <strong>pink floyd comfortably numb</strong> Â· <strong>daft punk get lucky</strong>';
        q.placeholder = 'artist song...';
    }
}

function stat(html) {
    document.getElementById('status').innerHTML = `<span class="st">${html}</span>`;
}

function tail(p) { return p.split('\\').pop(); }
function esc(s) { return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[c]); }

function toggleFilter() {
    showActive = !showActive;
    document.querySelector('.cat-btn').classList.toggle('on', showActive);
    dlPage = 1;
    mon();
}

function dlPg(d) { dlPage += d; mon(); }


/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• QUERY + SCORING â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

function clean(s) {
    return s.normalize('NFKD').replace(/[\u0300-\u036f]/g, '')
        .replace(/[''""`,!?;:()[\]{}<>@#$%^&*~_=+]/g, '')
        .replace(/\s*[-â€“â€”/|]+\s*/g, ' ')
        .replace(/\s+/g, ' ').trim();
}

function sigWords(q) {
    return q.toLowerCase().split(/\s+/).filter(w => w.length > 1 && !STOPS.has(w));
}

function relScore(text, ws) {
    if (!ws.length) return 0;
    const t = text.toLowerCase();
    let h = 0;
    for (const w of ws) if (t.includes(w)) h++;
    return h / ws.length;
}

function qualPts(files) {
    const n = files.length; if (!n) return CFG.W_LOW;
    const fl = files.filter(f => /\.flac$/i.test(f.filename)).length;
    if (fl / n >= 0.75) return CFG.W_FLAC;
    const avg = files.reduce((s, f) => s + (f.bitRate || 0), 0) / n;
    if (avg >= 320) return CFG.W_320;
    if (avg >= 256) return CFG.W_256;
    if (avg >= 192) return CFG.W_192;
    return CFG.W_LOW;
}

function isLowQuality(f) {
    if (/\.flac$/i.test(f.filename)) return false;
    return (f.bitRate || 9999) < CFG.MIN_KBPS;
}


/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• RANKING (returns top-N arrays) â•â•â•â•â•â•â•â•â•â•â•â• */

function rankAlbums(responses, ws) {
    const dirs = [];
    for (const r of responses) {
        const map = {};
        for (const f of (r.files || [])) {
            if (!AUDIO.test(f.filename) || isLowQuality(f)) continue;
            const parts = f.filename.split('\\');
            parts.pop();
            const key = r.username + '|' + parts.join('\\');
            if (!map[key]) {
                map[key] = {
                    username : r.username,
                    directory: parts.join('\\'),
                    dirName  : parts[parts.length - 1] || '?',
                    files    : [],
                    queueLen : r.queueLength        || 0,
                    freeSlot : r.hasFreeUploadSlot   || false
                };
            }
            map[key].files.push(f);
        }
        for (const d of Object.values(map))
            if (d.files.length >= CFG.MIN_TRACKS) dirs.push(d);
    }
    for (const d of dirs) {
        const rv = relScore(d.directory, ws);
        d.relevance = rv;
        let s  = rv * CFG.W_REL;
        s += qualPts(d.files);
        s += Math.min(d.files.length * CFG.W_TRACK, CFG.W_TRACK_CAP);
        if (d.freeSlot) s += CFG.W_SLOT;
        s -= Math.min(d.queueLen * CFG.W_Q_PEN, CFG.W_Q_CAP);
        if (NOISE.test(d.directory)) s -= CFG.W_NOISE;
        d.score = s;
    }
    let pool = dirs.filter(d => d.relevance >= CFG.REL_GATE);
    if (!pool.length) pool = dirs;
    pool.sort((a, b) => {
        if (b.score !== a.score) return b.score - a.score;
        return a.queueLen - b.queueLen;
    });
    return pool.slice(0, CFG.RETRY);
}

function rankTracks(responses, ws) {
    const pool = [];
    for (const r of responses) {
        for (const f of (r.files || [])) {
            if (!AUDIO.test(f.filename) || isLowQuality(f)) continue;
            const rv = relScore(f.filename, ws);
            if (rv < CFG.REL_GATE) continue;
            const isFl = /\.flac$/i.test(f.filename);
            let qs;
            if (isFl)                       qs = CFG.W_FLAC;
            else if ((f.bitRate||0) >= 320) qs = CFG.W_320;
            else if ((f.bitRate||0) >= 256) qs = CFG.W_256;
            else if ((f.bitRate||0) >= 192) qs = CFG.W_192;
            else                            qs = CFG.W_LOW;
            let s = rv * CFG.W_REL + qs;
            if (r.hasFreeUploadSlot) s += CFG.W_SLOT;
            s -= Math.min((r.queueLength||0) * CFG.W_Q_PEN, CFG.W_Q_CAP);
            if (NOISE.test(f.filename)) s -= CFG.W_NOISE;
            pool.push({
                username: r.username, file: f,
                score: s, relevance: rv,
                queue: r.queueLength||0,
                freeSlot: r.hasFreeUploadSlot||false
            });
        }
    }
    pool.sort((a, b) => b.score - a.score);
    return pool.slice(0, CFG.RETRY);
}


/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DOWNLOAD HELPERS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

async function jf(r) {
    if (r.status === 404 || r.status === 204) return null;
    const t = await r.text();
    try { return t ? JSON.parse(t) : null; } catch { return null; }
}

function prepPick(pick) {
    const isAlb = Array.isArray(pick.files) && pick.files.length > 1 && !pick.file;
    const user  = pick.username;
    let files, label;
    if (isAlb) {
        files = pick.files.map(f => ({ filename: f.filename, size: f.size }));
        const fl = pick.files.filter(f => /\.flac$/i.test(f.filename)).length;
        const qt = fl >= pick.files.length * .75 ? 'FLAC' : `${pick.files.length} files`;
        label = `ğŸ“‚ ${pick.dirName} Â· ${fl ? fl + ' FLAC' : qt} Â· ${user}`;
    } else {
        const f = pick.file || (pick.files && pick.files[0]);
        files = [{ filename: f.filename, size: f.size }];
        label = `â™« ${tail(f.filename)} Â· ${user}`;
    }
    return { user, files, label };
}

function collectFiles(ue) {
    const all = [];
    for (const dir of (ue.directories || []))
        for (const f of (dir.files || [])) all.push(f);
    if (!ue.directories && ue.files)
        for (const f of ue.files) all.push(f);
    return all;
}

async function dlState(user, filenames) {
    try {
        const r = await fetch(`${CFG.API_BASE}/transfers/downloads`,
                              { headers: { 'X-API-Key': CFG.API_KEY } });
        const data = await jf(r);
        if (!Array.isArray(data)) return 'pending';
        const ue = data.find(u => u.username === user);
        if (!ue) return 'pending';
        const all  = collectFiles(ue);
        const want = new Set(filenames.map(n => n.toLowerCase()));
        const matched = all.filter(f => f.filename && want.has(f.filename.toLowerCase()));
        if (!matched.length) return 'pending';

        let ok = 0, prog = 0, rej = 0, tout = 0, err = 0;
        for (const f of matched) {
            const st = f.state || '';
            if      (/Succeed/i.test(st))            ok++;
            else if (/Progress|Initializ/i.test(st)) prog++;
            else if (/Reject/i.test(st))             rej++;
            else if (/Timed|Timeout/i.test(st))      tout++;
            else if (/Error|Fail|Abort/i.test(st))   err++;
        }
        if (prog > 0) return 'progressing';
        if (ok === matched.length) return 'completed';
        if (rej  > 0) return 'rejected';
        if (tout > 0) return 'timedout';
        if (err  > 0) return 'errored';
        return 'pending';
    } catch { return 'pending'; }
}

async function awaitDl(user, filenames) {
    const deadline = Date.now() + CFG.RETRY_MS;
    await new Promise(ok => setTimeout(ok, CFG.RETRY_POLL));
    while (Date.now() < deadline) {
        const s = await dlState(user, filenames);
        if (s === 'rejected' || s === 'timedout' || s === 'errored') return 'failed';
        if (s === 'progressing' || s === 'completed') return 'ok';
        await new Promise(ok => setTimeout(ok, CFG.RETRY_POLL));
    }
    return 'ok';
}


/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• BACKGROUND WATCHER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

async function watchJobs() {
    for (const [id, job] of watchlist) {
        if (job.exhausted || job.retrying) continue;
        const grace = job.retries === 0 ? CFG.WATCH_GRACE : CFG.RETRY_MS * 2;
        if (Date.now() - job.queuedAt < grace) continue;

        const state = await dlState(job.user, job.filenames);
        if (state === 'completed') { watchlist.delete(id); continue; }
        if (state === 'progressing' || state === 'pending') continue;

        const next = job.attempt + 1;
        if (next < job.candidates.length && job.retries < CFG.WATCH_MAX) {
            job.retrying = true;
            try {
                const { user, files, label } = prepPick(job.candidates[next]);
                const dr = await fetch(
                    `${CFG.API_BASE}/transfers/downloads/${encodeURIComponent(user)}`, {
                        method : 'POST',
                        headers: { 'X-API-Key': CFG.API_KEY, 'Content-Type': 'application/json' },
                        body   : JSON.stringify(files)
                    });
                if (dr.ok || dr.status === 201) {
                    job.attempt   = next;
                    job.user      = user;
                    job.filenames = files.map(f => f.filename);
                    job.label     = label;
                    job.queuedAt  = Date.now();
                    job.retries++;
                } else {
                    job.attempt = next;
                }
            } catch (e) { console.error('[watch] retry error', e); }
            job.retrying = false;
        } else {
            job.exhausted = true;
        }
    }
    const stale = Date.now() - 7200000;
    for (const [id, job] of watchlist) {
        if (job.queuedAt < stale) watchlist.delete(id);
    }
}

function updateRetryArea() {
    const el = document.getElementById('retries');
    if (!el) return;
    const bars = [];
    for (const [id, job] of watchlist) {
        if (job.retrying) {
            bars.push(`<div class="retry-bar">
                <span><span class="s-load">â†»</span> retrying
                    <span class="query">"${esc(job.query)}"</span>
                    <span class="src">from ${esc(job.user)} Â· source ${job.attempt + 1}/${job.candidates.length}</span>
                </span>
            </div>`);
        } else if (job.exhausted) {
            bars.push(`<div class="retry-bar">
                <span><span class="s-err">âœ—</span>
                    <span class="query">"${esc(job.query)}"</span>
                    â€” all ${job.candidates.length} sources failed
                </span>
                <button class="retry-btn" onclick="manualRetry('${id}')">â†» retry search</button>
            </div>`);
        }
    }
    el.innerHTML = bars.join('');
}

function manualRetry(id) {
    const job = watchlist.get(id);
    if (!job) return;
    document.getElementById('q').value = job.query;
    if (mode !== job.mode) {
        const btns = document.querySelectorAll('.tog');
        setMode(job.mode, job.mode === 'album' ? btns[0] : btns[1]);
    }
    watchlist.delete(id);
    go();
}


/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DOWNLOAD MONITOR (table) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

setInterval(mon, CFG.MON_MS);

async function mon() {
    try {
        const r  = await fetch(`${CFG.API_BASE}/transfers/downloads`,
                               { headers: { 'X-API-Key': CFG.API_KEY } });
        const d  = await jf(r);
        const tb = document.getElementById('dl');
        const pg = document.getElementById('pager');
        const rows = [];

        if (Array.isArray(d)) for (const u of d) {
            const all = collectFiles(u);
            for (const f of all) rows.push({ user: u.username, f });
        }

        /* â”€â”€ filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        let visible = rows;
        if (showActive) {
            visible = rows.filter(({ f }) =>
                /Queue|Request|Initializ|Progress/i.test(f.state || '') || !(f.state || '')
            );
        }

        /* â”€â”€ cat button tooltip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        const catBtn = document.querySelector('.cat-btn');
        if (catBtn) {
            const h = rows.length - visible.length;
            catBtn.title = showActive
                ? `showing active only (${h} hidden) â€” click to show all`
                : 'hide completed â€” show active only';
        }

        /* â”€â”€ empty states â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        if (!visible.length && rows.length && showActive) {
            tb.innerHTML = '<tr><td colspan="4" class="empty">all downloads filtered â€” click ğ“ƒ  to show</td></tr>';
            pg.innerHTML = '';
        } else if (!visible.length) {
            tb.innerHTML = '<tr><td colspan="4" class="empty">nothing yet.</td></tr>';
            pg.innerHTML = '';
        } else {

            /* â”€â”€ paginate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
            const pages = Math.ceil(visible.length / CFG.PER_PAGE);
            dlPage = Math.max(1, Math.min(dlPage, pages));
            const start = (dlPage - 1) * CFG.PER_PAGE;
            const slice = visible.slice(start, start + CFG.PER_PAGE);

            tb.innerHTML = slice.map(({ user, f }) => {
                const p  = f.percentComplete != null
                         ? f.percentComplete.toFixed(1)
                         : f.size > 0 ? ((f.bytesTransferred||0)/f.size*100).toFixed(1) : '0.0';
                const st = f.state || 'â€¦';
                const c  = /complet.*succeed|succeed/i.test(st) ? 's-ok'
                         : /error|fail|abort|cancel|timed|reject/i.test(st) ? 's-err' : '';
                return `<tr>
                    <td title="${esc(f.filename)}">${esc(tail(f.filename))}</td>
                    <td>${esc(user)}</td>
                    <td><div class="bar-bg"><div class="bar-fg" style="width:${p}%"></div></div>${p}%</td>
                    <td class="${c}">${esc(st)}</td></tr>`;
            }).join('');

            /* â”€â”€ pager controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
            if (pages > 1) {
                const note = showActive ? '' : `<span class="pg-note">${visible.length} total</span>`;
                pg.innerHTML =
                    `<button class="pg-btn" onclick="dlPg(-1)" ${dlPage<=1?'disabled':''}>â—‚</button>` +
                    `<span class="pg-info">${dlPage} / ${pages}</span>` +
                    `<button class="pg-btn" onclick="dlPg(1)" ${dlPage>=pages?'disabled':''}>â–¸</button>` +
                    note;
            } else {
                pg.innerHTML = '';
            }
        }

        /* â”€â”€ background watcher â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        if (watchlist.size > 0 && Date.now() - lastWatch >= CFG.WATCH_POLL) {
            lastWatch = Date.now();
            await watchJobs();
        }
        updateRetryArea();

    } catch (e) { console.error('mon', e); }
}


/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MAIN HANDLER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

async function go() {
    const raw = document.getElementById('q').value;
    if (!raw.trim()) return;

    const q   = clean(raw);
    const ws  = sigWords(q);
    const btn = document.getElementById('goBtn');
    btn.disabled = true;
    stat(`<span class="s-load">searching "${esc(q)}" â€¦</span>`);

    try {
        const sr = await fetch(`${CFG.API_BASE}/searches`, {
            method: 'POST',
            headers: { 'X-API-Key': CFG.API_KEY, 'Content-Type': 'application/json' },
            body: JSON.stringify({ searchText: q })
        });
        if (!sr.ok) throw new Error(`search create failed (${sr.status})`);
        const sd = await jf(sr);
        if (!sd?.id) throw new Error('no search id returned');
        const sid = sd.id;

        let candidates = [], sources = 0, lastRes = [];

        for (let i = 0; i < CFG.POLLS; i++) {
            stat(`<span class="s-load">poll ${i+1}/${CFG.POLLS} Â· ${sources} sources</span>`);
            await new Promise(ok => setTimeout(ok, CFG.DELAY));

            const rr = await fetch(`${CFG.API_BASE}/searches/${sid}/responses`,
                                   { headers: { 'X-API-Key': CFG.API_KEY } });
            const rd = await jf(rr);
            if (!rd) continue;

            const res = Array.isArray(rd) ? rd
                      : Array.isArray(rd.responses) ? rd.responses : [];
            sources = res.length;
            if (!sources) continue;
            lastRes = res;

            candidates = mode === 'album' ? rankAlbums(res, ws) : rankTracks(res, ws);
            const best = candidates[0];

            if (best && mode === 'album'
                && best.relevance >= CFG.ALBUM_EXIT_REL
                && best.score     >= CFG.ALBUM_EXIT_SCORE
                && best.files.length >= CFG.ALBUM_EXIT_FILES
                && i >= CFG.ALBUM_EXIT_POLL) break;

            if (best && mode === 'track'
                && best.relevance >= CFG.TRACK_EXIT_REL
                && best.score     >= CFG.TRACK_EXIT_SCORE
                && i >= CFG.TRACK_EXIT_POLL) break;
        }

        let fb = null;
        if (!candidates.length && lastRes.length) {
            candidates = mode === 'album' ? rankTracks(lastRes, ws) : rankAlbums(lastRes, ws);
            if (candidates.length) fb = mode === 'album' ? 'track' : 'album';
        }

        if (!candidates.length) throw new Error(
            `no ${mode} results across ${sources} sources â€” try simpler or different terms`
        );

        let queued  = false;
        let lastErr = '';

        for (let a = 0; a < candidates.length; a++) {
            const { user, files, label } = prepPick(candidates[a]);
            const tag = candidates.length > 1 ? ` [${a+1}/${candidates.length}]` : '';

            stat(`<span class="s-load">queueing${tag} from ${esc(user)} â€¦</span>`);

            const dr = await fetch(
                `${CFG.API_BASE}/transfers/downloads/${encodeURIComponent(user)}`, {
                    method : 'POST',
                    headers: { 'X-API-Key': CFG.API_KEY, 'Content-Type': 'application/json' },
                    body   : JSON.stringify(files)
                });

            if (!dr.ok && dr.status !== 201) {
                lastErr = `queue failed (${dr.status})`;
                continue;
            }

            stat(`<span class="s-load">verifying${tag} â€¦</span>`);
            const result = await awaitDl(user, files.map(f => f.filename));
            if (result === 'failed') {
                lastErr = `${user} rejected / timed out`;
                stat(`<span class="s-mute">source ${a+1} failed, trying next â€¦</span>`);
                continue;
            }

            const fbNote = fb
                ? `<br><span class="s-mute">(no ${mode} found â€” used ${fb} mode)</span>` : '';
            const retryNote = a > 0
                ? `<br><span class="s-mute">(attempt ${a+1} of ${candidates.length})</span>` : '';
            stat(`<span class="s-ok">âœ“ queued â€” ${label}</span>${fbNote}${retryNote}`);
            document.getElementById('q').value = '';
            queued = true;

            /* save to watchlist */
            const jobId = Date.now().toString(36) + Math.random().toString(36).slice(2, 6);
            watchlist.set(jobId, {
                query: q, mode: fb || mode, ws, candidates,
                attempt: a, user, filenames: files.map(f => f.filename),
                label, queuedAt: Date.now(),
                retries: 0, exhausted: false, retrying: false
            });
            break;
        }

        if (!queued) throw new Error(
            `all ${candidates.length} sources failed (${lastErr})`
        );

        fetch(`${CFG.API_BASE}/searches/${sid}`,
              { method: 'DELETE', headers: { 'X-API-Key': CFG.API_KEY } }).catch(() => {});

    } catch (e) {
        stat(`<span class="s-err">âœ— ${e.message}</span>`);
        console.error(e);
    } finally {
        btn.disabled = false;
    }
}
</script>
</body>
</html>